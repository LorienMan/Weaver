//
//  XCFilelistGenerator.swift
//  WeaverCodeGen
//
//  Created by ThÃ©ophane Rupin on 1/30/19.
//

import Foundation
import PathKit

public final class XCFilelistGenerator {
    
    private let dependencyGraph: DependencyGraph
    
    private let projectPath: Path
    
    private let outputPath: Path
    
    private let singleOutput: Bool
    
    private let version: String
    
    public init(dependencyGraph: DependencyGraph,
                projectPath: Path,
                outputPath: Path,
                singleOutput: Bool,
                version: String) {
        self.dependencyGraph = dependencyGraph
        self.projectPath = projectPath
        self.outputPath = outputPath
        self.singleOutput = singleOutput
        self.version = version
    }
    
    public func generate() -> (input: String, output: String) {
        
        let inputFiles = dependencyGraph.dependencyContainersByFile.orderedKeys.map {
            "$SRCROOT/" + Path($0).relative(to: projectPath).string
        }

        let outputFiles: [String]
        if !singleOutput {
            outputFiles = dependencyGraph.dependencyContainersByFile.orderedKeys
                .compactMap { Path($0).components.last }
                .map { outputPath.absolute() + "Weaver.\($0)" }
                .map { "$SRCROOT/" + $0.relative(to: projectPath).string }
        } else {
            let file = outputPath.absolute() + "Weaver.swift"
            outputFiles = ["$SRCROOT/" + file.relative(to: projectPath).string]
        }
        
        let inputList = """
        /// This file is generated by Weaver \(version)
        /// DO NOT EDIT!
        \(inputFiles.joined(separator: "\n"))
        """
        
        let outputList = """
        /// This file is generated by Weaver \(version)
        /// DO NOT EDIT!
        \(outputFiles.joined(separator: "\n"))
        """
        
        return (input: inputList, output: outputList)
    }
}

private extension Path {
    
    func relative(to path: Path) -> Path {
        
        let components = absolute().components
        let pathComponents = path.absolute().components
        
        var i = 0
        while i < components.count && i < pathComponents.count {
            guard components[i] == pathComponents[i] else { break }
            i += 1
        }
        
        let absolutePath = components.suffix(from: i).reduce(Path()) { $0 + $1 }
        let relativePath = (i..<pathComponents.count).reduce(Path()) { path, _ in path + ".." }
        
        return relativePath + absolutePath
    }
}
